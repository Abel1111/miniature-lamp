name: Windows GetScreen.me Remote Access (Headless - No GUI)

on:
  workflow_dispatch:

jobs:
  setup-remote-access:
    runs-on: windows-latest # Explicitly use a Windows runner

    steps:
    - name: Download GetScreen.me Executable
      run: |
        $GETSCREEN_DOWNLOAD_URL = "https://getscreen.me/download/getscreen.exe"
        $GETSCREEN_EXE_PATH = "${env:TEMP}\getscreen.exe" # Download to temp directory

        echo "Downloading GetScreen.me from: ${GETSCREEN_DOWNLOAD_URL}"
        try {
            # Use curl.exe for reliable download with progress
            curl.exe -L -o "$GETSCREEN_EXE_PATH" "$GETSCREEN_DOWNLOAD_URL"
            if ($LASTEXITCODE -ne 0) {
                throw "curl.exe failed with exit code $LASTEXITCODE"
            }
            echo "Download successful."
        } catch {
            echo "Download failed: $_"
            exit 1 # Fail the step if download fails
        }
        echo "GetScreen.me downloaded to: ${GETSCREEN_EXE_PATH}"
      shell: powershell # Specify PowerShell for Windows commands

    - name: Launch GetScreen.me and Get Connection Info
      run: |
        $GETSCREEN_EXE_PATH = "${env:TEMP}\getscreen.exe"

        if (-not (Test-Path $GETSCREEN_EXE_PATH)) {
            echo "Error: GetScreen.me executable not found at ${GETSCREEN_EXE_PATH}. Aborting."
            exit 1
        }

        echo "Launching GetScreen.me in background..."
        # Launch GetScreen.me. It might self-extract or launch a service.
        # We expect it to run silently without a GUI pop-up in this environment,
        # or at least not block the script.
        # No specific headless flags are documented for getscreen.exe, so run it directly.
        Start-Process -FilePath "$GETSCREEN_EXE_PATH" -NoNewWindow -PassThru | Out-Null
        
        Start-Sleep -Seconds 30 # Give GetScreen.me time to initialize, connect, and write logs/config

        echo "Attempting to retrieve GetScreen.me connection information from common locations..."

        # Define common GetScreen.me data directories (educated guesses based on Windows app behavior)
        $APPDATA_PATH = "$env:APPDATA"       # C:\Users\user\AppData\Roaming
        $LOCALAPPDATA_PATH = "$env:LOCALAPPDATA" # C:\Users\user\AppData\Local

        $GETSCREEN_POSSIBLE_DIRS = @(
            "${APPDATA_PATH}\GetScreen.me",
            "${LOCALAPPDATA_PATH}\GetScreen.me",
            "${APPDATA_PATH}\getscreen", # Sometimes developers use lowercase
            "${LOCALAPPDATA_PATH}\getscreen"
        )

        $connectionInfoFound = $false
        $extractedInfo = "No connection information found."

        # Search for .log, .ini, .txt, or .json files in possible directories
        foreach ($dir in $GETSCREEN_POSSIBLE_DIRS) {
            echo "Searching for files in: ${dir}"
            if (Test-Path $dir) {
                # Find all relevant files in the directory and its subdirectories
                Get-ChildItem -Path $dir -Recurse -Include "*.log", "*.ini", "*.txt", "*.json" -ErrorAction SilentlyContinue | ForEach-Object {
                    $filePath = $_.FullName
                    echo "Checking file content: ${filePath}"
                    
                    # Read file content safely
                    $content = Get-Content $filePath -ErrorAction SilentlyContinue | Out-String

                    # Define patterns to look for:
                    # 1. Direct GetScreen.me connection link (e.g., getscreen.me/v/XXXXXXXX)
                    # 2. Separate ID and Password (often numerical ID, alphanumeric password)
                    $linkPattern = 'https?://getscreen\.me/v/\w+'
                    $idPattern = 'ID:\s*(\d{3}\s*\d{3}\s*\d{3}|\d+)' # Matches "ID: 123 456 789" or "ID: 123456789"
                    $passPattern = 'Password:\s*(\w+)'

                    $linkMatch = [regex]::Match($content, $linkPattern)
                    $idMatch = [regex]::Match($content, $idPattern)
                    $passMatch = [regex]::Match($content, $passPattern)

                    if ($linkMatch.Success) {
                        $extractedInfo = "GetScreen.me Connection Link: $($linkMatch.Value)"
                        $connectionInfoFound = $true
                        break # Exit ForEach-Object and outer loop
                    } elseif ($idMatch.Success -and $passMatch.Success) {
                        $extractedInfo = "GetScreen.me ID: $($idMatch.Groups[1].Value), Password: $($passMatch.Groups[1].Value)"
                        $connectionInfoFound = true
                        break # Exit ForEach-Object and outer loop
                    }
                }
            }
            if ($connectionInfoFound) { break } # Exit outer foreach loop if info found
        }

        # Output the found information or a message if not found
        echo "--- GetScreen.me Connection Information ---"
        echo "$extractedInfo"
        if (-not $connectionInfoFound) {
            echo "⚠️ No GetScreen.me connection information found in common log/config files."
            echo "This is expected if GetScreen.me does not output this information in a headless manner."
            echo "Manual retrieval might be required by connecting to the runner via SSH or another method."
        }
        echo "---------------------------------------"

        echo "Keeping runner alive for 30 minutes for potential manual connection..."
        Start-Sleep -Seconds 1800 # Keep the runner alive for 30 minutes (1800 seconds)
      shell: powershell # Ensure PowerShell is used for this step
