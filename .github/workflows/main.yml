---
name: Windows RustDesk Remote Access (Portable EXE)

on:
  workflow_dispatch:

jobs:
  setup-remote-access:
    runs-on: windows-latest

    steps:
    - name: Download RustDesk Portable Executable
      run: |
        $RUSTDESK_VERSION = "1.4.0"
        $EXE_FILENAME = "rustdesk-${RUSTDESK_VERSION}-x86_64.exe"
        $DOWNLOAD_URL = "https://github.com/rustdesk/rustdesk/releases/download/${RUSTDESK_VERSION}/${EXE_FILENAME}"
        $DOWNLOAD_PATH = "${env:TEMP}\${EXE_FILENAME}"

        echo "Downloading RustDesk portable executable from: ${DOWNLOAD_URL}"
        $MAX_RETRIES = 5
        $RETRY_DELAY = 10 # seconds

        for ($i = 0; $i -lt $MAX_RETRIES; $i++) {
            try {
                echo ("Attempt $($i + 1) of ${MAX_RETRIES}: Downloading ${DOWNLOAD_URL}")
                curl.exe -L -o "$DOWNLOAD_PATH" "${DOWNLOAD_URL}"
                if ($LASTEXITCODE -eq 0) {
                    echo "Download successful."
                    break
                } else {
                    throw "curl.exe failed with exit code $LASTEXITCODE"
                }
            } catch {
                echo "Download failed: $_"
                if ($i -lt ($MAX_RETRIES - 1)) {
                    echo "Retrying in $RETRY_DELAY seconds..."
                    Start-Sleep -Seconds $RETRY_DELAY
                } else {
                    echo "Max retries reached. Exiting."
                    exit 1
                }
            }
        }

        echo "RustDesk portable executable downloaded to: ${DOWNLOAD_PATH}"

        # Run the portable EXE briefly to allow it to unpack/self-extract to AppData\Local
        echo "Running RustDesk briefly to allow self-extraction and setup..."
        Start-Process -FilePath "$DOWNLOAD_PATH" -NoNewWindow -PassThru | Out-Null
        Start-Sleep -Seconds 15 # Give it enough time to extract and potentially start its service
        
        # REMOVED: Stop-Process as it causes NullReferenceException if process already exited
        echo "Initial RustDesk run complete. It should now be set up in AppData\Local."
      shell: powershell

    - name: Start RustDesk and Get Connection Info
      run: |
        # RustDesk (v1.4.0 portable) self-extracts to AppData\Local when first run.
        # We need to target this *actual* persistent executable location.
        $RUSTDESK_EXE = "${env:LOCALAPPDATA}\RustDesk\rustdesk.exe"

        if (-not (Test-Path $RUSTDESK_EXE)) {
            echo "Error: RustDesk executable not found at ${RUSTDESK_EXE} after self-extraction. Aborting."
            echo "Please ensure the initial run of the downloaded EXE successfully extracted it."
            exit 1
        }

        echo "Starting RustDesk from its extracted location: ${RUSTDESK_EXE}"
        # Start RustDesk in the background as a service to ensure it runs headless.
        Start-Process -FilePath $RUSTDESK_EXE -ArgumentList "--service", "--enable-service" -NoNewWindow -PassThru | Out-Null
        Start-Sleep -Seconds 30 # Give RustDesk time to initialize and generate ID/password

        echo "Attempting to retrieve RustDesk ID and Password from log file or configuration..."
        $APPDATA_RUSTDESK_PATH = "$env:APPDATA\RustDesk"
        $RUSTDESK_LOG_DIR = "$APPDATA_RUSTDESK_PATH\log\service" 
        
        echo "Checking log files in: ${RUSTDESK_LOG_DIR}"

        # NEW: Add a waiting loop to ensure the log file is found and written
        $logFileFound = $false
        $waitRetries = 12 # Check up to 12 times
        $waitDelay = 5 # Wait 5 seconds between checks (total up to 60 seconds)
        $recentLogFile = $null

        for ($i = 0; $i -lt $waitRetries; $i++) {
            # Try to find the log file
            $recentLogFile = Get-ChildItem $RUSTDESK_LOG_DIR -Filter "rustdesk_r*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
            if ($recentLogFile -ne $null -and (Get-Content $recentLogFile.FullName -Raw).Length -gt 0) { # Also check if file has content
                echo "Log file found and has content after $($i * $waitDelay) seconds."
                $logFileFound = $true
                break
            }
            echo "Waiting for log file in ${RUSTDESK_LOG_DIR}... (Attempt $($i + 1))"
            Start-Sleep -Seconds $waitDelay
        }

        if ($logFileFound) {
            echo "--- Content of latest RustDesk service log file ($($recentLogFile.FullName)) ---"
            # Add a small delay before reading the content one last time to ensure full write
            Start-Sleep -Seconds 2 
            $logContent = Get-Content $recentLogFile.FullName -Raw
            echo $logContent
            echo "------------------------------------"

            $rustdeskId = [regex]::Match($logContent, 'ID: (\d+)').Groups[1].Value
            $rustdeskPass = [regex]::Match($logContent, 'Password: (\w+)').Groups[1].Value

            if (-not [string]::IsNullOrEmpty($rustdeskId)) {
                echo "RustDesk ID: ${rustdeskId}"
                echo "RustDesk Password (check logs above or retrieve manually): ${rustdeskPass}"
            } else {
                echo "Could not find RustDesk ID in log file after reading. Manual retrieval is likely required."
            }
        } else {
            echo "No recent log files found in ${RUSTDESK_LOG_DIR} after waiting. Manual retrieval of ID/Password is required."
        }

        echo "--- Manual Connection Details ---"
        echo "Connect using the RustDesk client on your local machine."
        echo "You will need the RustDesk ID and Password. Look for them in the RustDesk UI after it starts on the runner,"
        echo "or within its configuration/log files (typically in %APPDATA%\RustDesk), or use an SSH session to the runner to view them."
        echo "---------------------------------"

        echo "Keeping runner alive for 30 minutes..."
        timeout /t 1800 /nobreak
      shell: powershell
